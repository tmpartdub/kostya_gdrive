#№ Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Лукашкин К.В.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|   26.12.17   |   4           |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*
Включите в отчет описание грамматики (четверка: терминальный нетерминальный алфавит, правила перехода, начальный символ).

## Введение

Естественный язык – очень сложная система с неочевидной и гибкой структурой. Любой анализ естественного языка сводиться к нескольким этапам: предварительный анализ (поиск границ слов и предложений), морфологический анализ (установление словарных форм слов и приписывание им морфологических признаков), синтаксический анализ (зависимости между словами), семантический анализ (смысл предложения или отдельных слов). 
Грамматика описывает закономерности устройства языка, но она имеет описательный характер и, к сожалению, не всегда содержит явные и чёткие правила формирования предложений. Самой главной задачей анализа естественного языка является выявление закономерностей. В этом используется два подхода -- работа эксперта-лингвиста и автоматическое исследование размеченных данных.

В данной работе будет использоватся первый подход, будет исследована ограниченная часть языка, и в ней выделены правила грамматики.
Грамматика в таком случае будет характеризоватся двумя множествами -- терминальными и нетерминальными элементами, а также правилами перехода, которые будут учитывать контекст. 

Пролог удобен для таких задач, т.к. на нём удобно описывать грамматику, она понятна человеку, который читает код, и в то же время человеку, который его пишет.

Для искусственного языка характерна строгая структура и конкретные правила синтаксиса, семантики и пр. Обработка искусственного языка проводится транслятором (компилятором), который обо всех правилах осведомлен и не предполагает за собой эвристики.

Насколько Пролог эффективен для анализа естественных языков вопрос спорный, поскольку в наше время чаще всего используется не языки логического программирования, а второй подход -- автоматическое обучение на больших объёмах данных, где определение грамматики предоставлено программе, и человеку невозможно понять закономерности которые вывела программа. 

## Задание
![Задание](https://pp.userapi.com/c841032/v841032833/47576/w4ZfJQz-kPA.jpg)

## Принцип решения

Глубинная форма -- форма содержащая в себе только смысл части предложения, без морфологических признаков, не требующая пояснения форм слов.

Активная и пассивная формы отличаются тем как действие связывает субъект и объект . Пример активной формы: Маша любит шоколад, пассивной: шоколад любим Машей. Прекрасно видно чем они отличаются: глагол стоит в активном или пассивном залоге, и падежи существительных отличаются. Эти закономерности и лежат в основе программы.

Поскольку структура программы довольно сложна, сперва поясню как производится разбор одной фразы, и лишь в самом конце перейду к полноценной задаче.

### Анализ отдельной фразы

`a_phrase(P, zalog(_), L)` анализ фраз в различных формах
```
%Анализ фразы в активном залоге
a_phrase(P, zalog('актив'), L):-
  append([X|XT], [Y|Z], L),
  glag(X2, zalog('актив'), Y),
  compose_agent(X1, pad('именит'), [X|XT]),
  compose_agent(X3, pad('винит'), Z),
  P = [X2, X1 ,X3].

%Анализ фразы в пассивном залоге
a_phrase(P, zalog('пассив'),L):-
  append([X|XT], [Y|Z], L),
  glag(X2, zalog('пассив'), Y),
  compose_agent(X1, pad('именит'), [X|XT]),
  compose_agent(X3, pad('творит'), Z),
  P = [X2, X3 ,X1].
```
Фраза задается списком L который разбивается на три части: глагол, объект, субъект (все они непустые).

### Составление групп субъекта и объекта

`compose_agent(Answer, zalog(_), Text)` Составление группы существительных (возможно соединенных союзом и)
```
%несколько существтельных соединенных союзом
compose_agent([X|Ans], K,[H,Y|T]):-
  agent(X, K, H),
  union(Y),
  compose_agent(Ans, K, T).
%одно существительное
compose_agent([X], K,[H]):-
  agent(X, K, H).
```
Из фразы формируется список с существительными в глубинной форме (союз в список не входит).

### Анализ слова

`agent(XC, K, X)` Получение глубинной формы существительного

`glag(XC, K, X)` Получение глубинной формы глагола


```
%Предикат существительного
agent(XC, K, X):-
  gen_mest(File_mest),
  fid(X, XC, K, File_mest).

%предикат глагола
glag(XC, K, X):-
  gen_glag(File_glag),
  fid(X, XC, K, File_glag).
```

Генерируется словарь и вызывается функция поиска слова в словаре

### Поиск глубинной формы слова

`fid(Word, Ans, Form, File)` Поиск слова по всему словарю

`condition(Word, Ans, Form, Ans:Form:List)` Поиск и выделение глубинной формы слова по конкретной строке в словаре

``` 
%поиск словоформы в словаре
fid(X, XC, K, File):-
  member(M, File),
  condition(X, XC, K, M).

condition(X, XC, K, XC:K:L):-
  member(X, L).
```
Выделяется строчка словаря и для неё вызывается `condition` для выделения глубинной формы из формы `K`

### Подробнее о структуре словаря:

Для структуры словаря зарезервирован оператор `op(200, xfy, ':').` 
Запись в словаре имеет вид:
```
"Глубинная форма' : форма слова : [Список вариаций слова в этой форме]
Например
'Маша':pad('творит'):['Машей']
'любить':zalog('пассив'):['любим', 'любима', 'любимо', 'любимы']
```

### Главная процедура

`compare(Фраза1, Фраза2, Гл.Структура1, Гл.Структура2, Равны?)` Построение глубинных структур фраз и их сравнение

```
%СРАВНИТЬ ДВЕ ФРАЗЫ НА ЕСТЕССТВЕННОМ ЯЗЫКЕ
%представив их глубинной структурой
%(Фраза1, Фраза2, Гл.Структура1, Гл.Структура2, Равны?)
compare(X,Y,Ph1,Ph2,Eq):-
  %Выделение структуры фраз
  a_phrase(Ph1,_,X),
  a_phrase(Ph2,_,Y),
  Ph1 = [A, Obj1, Subj1],
  Ph2 = [B, Obj2, Subj2],
  %Сортировка списков объектов и субъектов
  %чтобы фразы с различным их порядком следования были равными
  sort(Obj1,S1),
  sort(Subj1, S2),
  sort(Obj2, S3),
  sort(Subj2, S4),
  %непосредственно сравнение
  cmp([A,S1,S2],[B,S3,S4],Eq).

%СРАВНЕНИЕ
%(Объект 1, Объект2, yes/no)
cmp(X,Y,Ans):-
  X = Y,
  Ans = 'yes', !.
cmp(_,_,'no').
```
В ней происходит вызов анализатора фразы для заданных фраз, затем их списки объектов и субъектов сортируются (чтобы фразы с различным их порядком следования были равными), выполняется определение их идентичности.

## Результаты
```
?- compare(['Саша', 'и', 'Лена', 'любят', 'шоколад'] , ['шоколад', 'любим','Сашей', 'и', 'Леной'], Ph1,Ph2, Y).
Ph1 = Ph2, Ph2 = [любить, ['Саша', 'Лена'], [шоколад]],
Y = yes .

?- compare(['Маша','и','аниме', 'любят', 'деньги'],['деньги','и','аниме','любимо','Машей'],Ph1,Ph2,Y).
Ph1 = [любить, ['Маша', аниме], [деньги]],
Ph2 = [любить, ['Маша'], [деньги, аниме]],
Y = no .

?- compare(['Лена','и','Петя', 'обожают', 'программирование','и','деньги'],['деньги','и','программирование','обожаемы','Петей','и','Леной'],Ph1,Ph2,Y).
Ph1 = [обожать, ['Лена', 'Петя'], [программирование, деньги]],
Ph2 = [обожать, ['Петя', 'Лена'], [деньги, программирование]],
Y = yes .
```

## Выводы


Проделав лабораторную работу, я составил несложный фрагмент естественного-языкового интерфейса к модельной задаче. Мною была реализована грамматика для небольшой части русского языка: активной и пассивной формах. Я составил грамматические правила для этой части и вынес слова в словарь. Таким образом можно подключать словари и выполнять программу для различных слов. 

Пролог был удобен для решения задач грамматического разбора: реализация правил перехода довольно очевидна и проста.

Возможно ли таким методом формализовать весь русский язык? Я думаю, что нет. Создание правил осложняется многими аспектами, например, анафорами (распознаванием, что имеется в виду при использовании местоимений), свободным порядком слов, да и просто богатством естественного, в частности русского, языка. Структуризация такого огромного массива данных представляется нереальной для человека. Также стоит учитывать изменчивость языка: будет ли человек успевать учитывать изменения при разработке такой глобальной системы? 

Решение подобной проблемы приводит к попытке автоматизации этой структуризации. Очень привлекательными в таком плане выглядят нейронные сети, в частности, рекуррентные нейронные сети. Разработки и исследования в этой области очень активны сейчас. 

Хотя определенного успеха в распознавании естественного языка человечество уже добилось. Например, интернет-поисковики. Их интерфейс реализован как упрощенная модель естественного языка. Или автоматические переводчики, которые выдают более менее хорошие результаты для простых конструкций.
