#№ Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### студент: Лукашкин К.В.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|  23.12.17    |      4        |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*
Проанализировать решение на единственность, безопасность, непротиворечивость.


## Введение

Решение логических задач имеет 2 основных подхода: метод порождения и проверок и метод ветвей и границ. Главное их своство в том, что они перебирают набор решений, и проверяют, удовлетворяет ли он заданным условиям. 
Их различие сводится к методам проверки удовлетворения заданным условиям. Метод проверок можно разделить на две отдельные части: первая часть генератор: она пытается угадать данные (генерирует множество исходных данных), и второй части -- проверяющего. Проверяющий, соответсвенно проверяет пришедшее ему решение. Второй метод серьёзно отличается от первого. В методе ветвей и границ проверяющий и генератор тесно связаны: генерация всех условий происходит не моментально (сразу все), а постепенно, шагами. Значительные части возможных, но неверных, решений отсекаются на ранних шагах. 

Например, в моём задании было использовано `before(man(_, 'Aвтомеханик'), man(_, 'Строитель'),  Chess),` Сразу после генерации списка успехов в шахматах -- это отсекает много возмоможных вариантов, хотя данное условие сказано лишь в самом конце задачи. Второй метод, более сложен по сравнению с наивным первым, и значительно производительней, поэтому он предпочтительней.

Пролог очень удобен для решения логических задач, что подтверждает статус языка логического программирования. Он предоставлет возможность гибкого перебора большого количества вариантов решения. Механизм бэктрекинга при неуспехе пересматривает решение лишь до последнего выбора, не меняя ранее идущих выборов, это и поределяет необычайную мощность Пролога для задач подобного плана.

## Задание
8. Борисов, Кириллов, Данин и Савин инженеры. Один из них автомеханик, другой химик, третий строитель, четвертый радиотехник. Борисов, который обыгрывает в шахматы Данина, но проигрывает Савину, бегает на лыжах лучше того инженера, который моложе его, и ходит в театр чаще, чем тот инженер, который старше Кириллова. Химик, который посещает театр чаще, чем автомеханик, но реже, чем строитель, не является ни самым молодым, ни самым старшим из этой четверки. Строитель, который на лыжах бегает хуже, чем радиотехник, как правило, проигрывает в шахматных сражениях автомеханику. Самый пожилой из инженеров лучше всех играет в шахматы и чаще всех бывает в театре, а самый молодой лучше всех ходит на лыжах. Назовите профессии каждого из инженеров, если известно, что ни в спорте, ни в приверженности к театру среди нет двух одинаковых.

## Принцип решения
```
['Борисов','Кириллов','Данин','Савин']=[X, Y, Z, K],
  permutation(['Строитель','Aвтомеханик','Химик','Радиотехник'],
    [Xprof, Yprof, Zprof, Kprof]),
  Mans = [man(X, Xprof), man(Y, Yprof), man(Z, Zprof),  man(K, Kprof)],
```
Главный предикат `solve(Mans)`,  `Mans` представляет из себя список термов `man(Name, Prof)`. Решение сводиться к поиску такой перестановки профессий которое будет удовлетворять условиям задачи.

Чтобы определить насколько человек успешен в шахматах будет использоваться перестановка:
```
permutation(Mans,Chess),
```
Чем ближе человек к началу списка, тем лучше он себя показывает в данной категории. Для задания условий используются предикаты абсолютной позиции:
```
bottom(D,[_,_,_,D]).
medium(C,[_,_,C,_]).
medium(B,[_,B,_,_]).
top(A,[A,_,_,_]).
```
и относительной позиции:
```
% X раньше (старше/быстрее/чаще посещает театр/играет в шахматы лучше) Y
before(X,Y,[X|T]):-
    member(Y,T).
before(X,Y,[_|T]):-
    before(X,Y,T).
```

Поскольку в задаче много однотипных и похожих условий, отличающихся лишь значениями, приведу типовые условия:

Борисов обыгрывает в шахматы Данина:
```
  before( man('Борисов', _),man('Данин', _), Chess),
```

Борисов бегает на лыжах лучше того инженера, который моложе его:
```
  member(Somebody1, Mans),
  before(man('Борисов', _), Somebody1, Ski),
  before(man('Борисов', _), Somebody1, Age),
```

Самый пожилой из инженеров чаще всех бывает в театре:
```
  top(Grandpa,Theater),
```

Уменьшение перебираемых условий достигается за счёт как можно более позднего обращения к предикатам:
```
  %посещение театра
  permutation(Mans,Theater),
```
и им подобным. С этой целью был изменен порядок проверки условий.

Результаты выполнения программы:

```
?- solve(X).
X = [man('Борисов', 'Строитель'), man('Кириллов', 'Aвтомеханик'), man('Данин', 'Химик'), man('Савин', 'Радиотехник')] .

```
Это единственно верное непротиворечивое решение. Все условия задачи соблюдены. Поскольку я использую предикат `permutation`, который возвращает перестановку элемента списка местами, не учитываются заведомо неверные возможные решения, в которых несколько инженеров имеют одну профессию. Также позиция имён фиксирована, перестановки выполняются с профессиями (затем только со списком в котором содержатся термы `man` для создания таблицы с успехами в лыжном спорте и т.п.), это позволяет не учитывать решения в которых переставлены местами люди. Например: Борисов-Строитель Кириллов-Автомеханик; Кириллов-Автомеханик Борисов-Строитель.


## Выводы

Пролог очень удобен для решения логических задач. Подобные задачи человеку решать таким методом, которым их решает Прлог практически нереально: слишком много возможных вариантов. Вместо этого используются различные приёмы, например, метод исключения и логический квадрат. Если говорить о кретивной части решения Прологом, в программе отсутствуют изящные логические выводы и хитрости, задача ломается под мощью перебора (который тем не менее оптимизирован), это хороший пример использования скорости недоступной человеческому мышлению: работа программиста -- лишь объяснить задачу машине, и она сию же секунду выдаст правильное решение. Человек может просидеть с даннной задачей пару вечеров, получив, правда, несколько более "красивое" решение.

По поводу повторной используемости данного кода (и применения его в общем и целом), сложно придумать ситуацию, при которой бы возникала необходимость решать большое количество однотипных логических задач -- ситуацию в которой нужно применять данную программу. Тем не менее поскольку условия задачи чётко разделяются на типы, можно представить себе генератор, который будет либо создавать задачи подобного плана, для применения, например, в учебных целях, либо решать такие типовые задачи, самостоятельно генерируя проверки из условий задач. 
